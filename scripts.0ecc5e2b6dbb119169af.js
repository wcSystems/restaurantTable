var canvas=document.getElementById("canvas");canvas.width=window.innerWidth,canvas.height=window.innerHeight;var gl=canvas.getContext("webgl");gl||console.error("Unable to initialize WebGL.");var time=0,vertexSource="\nattribute vec2 position;\nvoid main() {\n\tgl_Position = vec4(position, 0.0, 1.0);\n}\n",fragmentSource="\nprecision highp float;\n\nuniform float width;\nuniform float height;\nvec2 resolution = vec2(width, height);\n\nuniform float time;\n\n//Base values modified with depth later\nfloat intensity = 1.0;\nfloat radius = 0.05;\n\n//Distance functions from \n//https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat triangleDist(vec2 p){ \n\tconst float k = sqrt(3.0);\n  p.x = abs(p.x) - 1.0;\n  p.y = p.y + 1.0/k;\n  if( p.x+k*p.y>0.0 ) p=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n  p.x -= clamp( p.x, -2.0, 0.0 );\n  return -length(p)*sign(p.y);\n}\n\nfloat boxDist(vec2 p){\n  vec2 d = abs(p)-1.0;\n  return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat circleDist( vec2 p){\n  return length(p) - 1.0;\n}\n\n//https://www.shadertoy.com/view/3s3GDn\nfloat getGlow(float dist, float radius, float intensity){\n  return pow(radius/dist, intensity);\n}\n\nvoid main(){\n    \n\tvec2 uv = gl_FragCoord.xy/resolution.xy;\n  float widthHeightRatio = resolution.x/resolution.y;\n  vec2 centre;\n  vec2 pos;\n\t\n  float t = time * 0.05;\n    \n  float dist;\n  float glow;\n  vec3 col = vec3(0);\n    \n  //The spacing between shapes\n  float scale = 500.0;\n  //Number of shapes\n  const int layers = 15;\n    \n  float depth;\n  vec2 bend;\n    \n  vec3 purple = vec3(0.611, 0.129, 0.909);\n  vec3 green = vec3(0.133, 0.62, 0.698);\n    \n  float angle;\n  float rotationAngle;\n  mat2 rotation;\n    \n  //For movement of the anchor point in time\n  float d = 2.5*(sin(t) + sin(3.0*t));\n\n  //Create an out of frame anchor point where all shapes converge to    \n  vec2 anchor = vec2(0.5 + cos(d), 0.5 + sin(d));\n    \n  //Create light purple glow at the anchor loaction\n  pos = anchor - uv;\n  pos.y /= widthHeightRatio;\n  dist = length(pos);\n  glow = getGlow(dist, 0.2, 1.9);\n  col += glow * vec3(0.7,0.6,1.0);\n    \n\tfor(int i = 0; i < layers; i++){\n        \n  \t//Time varying depth information depending on layer\n    depth = fract(float(i)/float(layers) + t);\n\n    //Move the focus of the camera in a circle\n    centre = vec2(0.5 + 0.2 * sin(t), 0.5 + 0.2 * cos(t));\n        \n   \t//Position shapes between the anchor and the camera focus based on depth\n   \tbend = mix(anchor, centre, depth);\n     \t\n    pos = bend - uv;\n   \tpos.y /= widthHeightRatio;\n\n    //Rotate shapes\n    rotationAngle = 3.14 * sin(depth + fract(t) * 6.28) + float(i);\n    rotation = mat2(cos(rotationAngle), -sin(rotationAngle), \n                    sin(rotationAngle),  cos(rotationAngle));\n        \n    pos *= rotation;\n        \n    //Position shapes according to depth\n    pos *= mix(scale, 0.0, depth);\n    \t\n    float m = mod(float(i), 3.0);\n    if(m == 0.0){\n    \tdist = abs(boxDist(pos));\n    }else if(m == 1.0){\n      dist = abs(triangleDist(pos));\n    }else{\n    \tdist = abs(circleDist(pos));\n    }\n       \n    //Get glow from base radius and intensity modified by depth\n    glow = getGlow(dist, radius+(1.0-depth)*2.0, intensity + depth);\n        \n    //Find angle along shape and map from [-PI; PI] to [0; 1]\n    angle = (atan(pos.y, pos.x)+3.14)/6.28;\n    //Shift angle depending on layer and map to [1...0...1]\n\t\tangle = abs((2.0*fract(angle + float(i)/float(layers))) - 1.0);\n        \n    //White core\n   \t//col += 10.0*vec3(smoothstep(0.03, 0.02, dist));\n        \n    //Glow according to angle value\n    col += glow * mix(green, purple, angle);\n\t}\n    \n  //Tone mapping\n  col = 1.0 - exp(-col);\n    \n  //Output to screen\n  gl_FragColor = vec4(col,1.0);\n}\n";function onWindowResize(){canvas.width=window.innerWidth,canvas.height=window.innerHeight,gl.viewport(0,0,canvas.width,canvas.height),gl.uniform1f(widthHandle,window.innerWidth),gl.uniform1f(heightHandle,window.innerHeight)}function compileShader(n,t){var e=gl.createShader(t);if(gl.shaderSource(e,n),gl.compileShader(e),!gl.getShaderParameter(e,gl.COMPILE_STATUS))throw"Shader compile failed with: "+gl.getShaderInfoLog(e);return e}function getAttribLocation(n,t){var e=gl.getAttribLocation(n,t);if(-1===e)throw"Cannot find attribute "+t+".";return e}function getUniformLocation(n,t){var e=gl.getUniformLocation(n,t);if(-1===e)throw"Cannot find uniform "+t+".";return e}window.addEventListener("resize",onWindowResize,!1);var vertexShader=compileShader(vertexSource,gl.VERTEX_SHADER),fragmentShader=compileShader(fragmentSource,gl.FRAGMENT_SHADER),program=gl.createProgram();gl.attachShader(program,vertexShader),gl.attachShader(program,fragmentShader),gl.linkProgram(program),gl.useProgram(program);var vertexData=new Float32Array([-1,1,-1,-1,1,1,1,-1]),vertexDataBuffer=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,vertexDataBuffer),gl.bufferData(gl.ARRAY_BUFFER,vertexData,gl.STATIC_DRAW);var positionHandle=getAttribLocation(program,"position");gl.enableVertexAttribArray(positionHandle),gl.vertexAttribPointer(positionHandle,2,gl.FLOAT,!1,8,0);var timeHandle=getUniformLocation(program,"time"),widthHandle=getUniformLocation(program,"width"),heightHandle=getUniformLocation(program,"height");gl.uniform1f(widthHandle,window.innerWidth),gl.uniform1f(heightHandle,window.innerHeight);var thisFrame,lastFrame=Date.now();function draw(){thisFrame=Date.now(),time+=(thisFrame-lastFrame)/1e3,lastFrame=thisFrame,gl.uniform1f(timeHandle,time),gl.drawArrays(gl.TRIANGLE_STRIP,0,4),requestAnimationFrame(draw)}draw();